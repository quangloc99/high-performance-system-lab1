\documentclass{article}
\usepackage[a4paper, margin=1in]{geometry}

%Russian-specific packages
%--------------------------------------
\usepackage[tuenc]{fontspec}%for lualatex case
\usepackage[T2A]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{indentfirst}
% \usepackage[english,russian]{babel} 
\setsansfont{CMU Sans Serif}%{Arial}
\setmainfont{CMU Serif}%{Times New Roman}
\setmonofont{CMU Typewriter Text}%{Consolas}

\usepackage{tikz}
\usepackage{minted}
% \usepackage{algoflowchart}      % <-- this is a local package, and I am the author 
\usepackage{graphicx}
\usemintedstyle{borland}

\renewcommand{\familydefault}{\rmdefault}
\def\requiredField#1{\textcolor{red}{#1}}

\begin{document}
\begin{titlepage}
    \begin{center} «Национальный исследовательский университет ИТМО» \end{center}

    \vfill
    \begin{center}
        \textbf{\huge
            Лабораторная работа №1 по дисциплину
            "Высокопроизводительные системы"
        } \\
        \medskip
        Номер варианта - 10

    \end{center}

    \vfill

    \begin{flushright}
        Выполнил: Чан Куанг Лок\\
        Группа: P43011
    \end{flushright}

    \begin{center}
        Санкт-Петербург\\ 2021 г
    \end{center}
\end{titlepage}

\section{Описание задания}
\subsection{Цели работы}
Распараллеливание алгоритма сортировки, заданным вариантом, с библиотекой OpenMP
и анализ результатов.
\subsection{Полное текст задания}
Реализовать алгоритмы сортировки в соответствии с вариантом задания.
Параллелизовать реализованные алгоритмы с помощью OpenMP, применяя для каждого
общий набор из разных подходов для распределения частей работы и объединения
результатов. Собрать статистику о времени работы реализованных алгоритмов в
целом и отдельных этапов в реализациях для различных наборов входных данныхв
сочетании с различными степенями параллелизма. Сравнить все полученные
реализации: разные алгоритмы попарно для каждого подхода и отдельно все
реализации каждого алгоритма между собой. Объяснить результаты.

\subsection{Вариант}
\begin{tabular}{|c|c|}
    \hline
    Алгоритм 1 & Алгоритм 2 \\
    \hline
    Timsort & Двоичным деревом \\
    \hline
\end{tabular}
    

\section{Задачи}
\begin{enumerate}
    \item Понимание инструмента и алгоритма:
        \begin{itemize}
            \item Библиотека OpenMP:
            \verb`https://www.openmp.org/resources/tutorials-articles/`
            
            \item Алгоритм Timsort:
                \verb`https://en.wikipedia.org/wiki/Timsort`
            
            \item Аогоритм сортировка двоичным деревом:
                \verb`https://en.wikipedia.org/wiki/Tree_sort`
            
        \end{itemize}
    \item Изменение алгоритма, чтобы распараллелить его.
    \item Реализовать алгоритм.
    \item Подготовка тестовых данных.
    \item Запуск кода и анализ результатов.
\end{enumerate}

\section{Описание работы}

Эти 2 алгоритма объявлены как 2 функции, лежащие в заголовках
«parallelized-modified-timsort.hpp» и «parallelized-treesort.hpp»
соответственно, а также их реализация в соответствующих файлах «cpp». Две
функции:

\begin{itemize}
    \item \verb`void parallelized_modified_timsort(int* begin, int* end);`
    \item \verb`void parallelized_treesort(int* begin, int* end);`
\end{itemize}

Их подпись и использование одинаковы. Эти функции будут принимать 2 указателя на
начало и конец массива, который необходимо отсортировать, то есть функция будет
отсортировать полуинтервал \verb`[begin, end)`.  Я решил, что у них будет почти
такая же сигнатура, что и у функций \verb`std::sort`, но в целях демонстрации я
сделал это только с \verb`int`, а не с другими типами (то есть без шаблона).

В дополнение к сортировке двоичным деревом также предоставили его рандомизированную
версию, чтобы она не попадала в вырожденный случай.


Пример использования:
\begin{minted}{cpp}
#include "parallelized_modified_timsort.hpp"
#include "parallelized_treesort.hpp"

int main() {
    int n;                 // the number of elements
    int arr[n] = { ... };  // elements of the array here
    parallelized_modified_timsort(arr, arr + n);
    // or
    parallelized_treesort(arr, arr + n);
    // or
    randomized_parallelized_treesort(arr, arr + n);
    
    // for vector, one can access the raw array with the method ::data()
}
\end{minted}

\section{Аспекты реализации}
\subsection{Timsort}
Timsort - это высокооптимизированная сортировка слиянием с множеством плюсов:
адаптивность, стабильность и компактность. Но в его дизайне \textbf{не было
параллелизма}. Он поддерживает стек «прогонов» (уже отсортированные сегменты в
исходном массиве) и пытается объединить прогоны (с помощью стандартного
алгоритма слияния отсортированных массивов), чтобы удовлетворить «критериям
слияния». И работа по поддержанию этого стека идет \textbf{последовательно}.

Итак, здесь я сделал модификацию этого алгоритма, применив подход «разделяй и
властвуй». Сначала я нахожу пробег, содержащий средний элемент. Затем я
попытался отсортировать левый и правый элемент этого прогона. После этого я
объединяю 3 подмассива в один. Этот алгоритм «почти» такой же, как и
оригинальный Timsort, потому что он также адаптивен и стабилен. Но ради
распараллеливания я жертвую аспектом экономии места, потому что несколько
потоков в любом случае будут использовать временный буфер. Чтобы сделать это
быстро, до того, как алгоритм сработает, я выделил буфер, а затем очистил его.

\subsubsection{Реализация}
Header file
  \inputminted[fontsize=\footnotesize]{cpp}{./parallelized-modified-timsort.hpp}  
  
Source file
  \inputminted[fontsize=\footnotesize]{cpp}{./parallelized-modified-timsort.cpp}  

\subsection{Сортировка двочиным деревом}
Этот алгоритм является аналогом быстрой сортировки. Уже существует
распараллеленная версия быстрой сортировки, поэтому здесь я попытался сделать то
же самое с подходом «разделяй и властвуй». Чтобы отличить этот алгоритм от
быстрой сортировки, я фактически построю дерево, а затем сгладю его.

А также, чтобы не соответствовать случаю $O(n^2)$, я также предоставил
рандомизированную версию, то есть перетасовываю массив до того, как сработает
алгоритм.

\subsubsection{Реализация}

Header file
  \inputminted[fontsize=\footnotesize]{cpp}{./parallelized-treesort.hpp}  
Source file
  \inputminted[fontsize=\footnotesize]{cpp}{./parallelized-treesort.cpp}  
  
\section{Результат}

Код запускается с несколькими тестовыми данными. Тестируются 4 вида
последовательностей: случайные, отсортированные, обратносортированные и
одинаковые по значению. И есть 3 диапазона длины последовательности: малая (от 0
до 300 элементов), средняя (от $10^3$ до $10^5$ элементов) и большая (от $10^6$
до $10^7$ элементов). Чтобы сэкономить время, тест на большую длину
последовательности будет запускаться только со случайным значением. Таким
образом, у нас есть 9 тестовых комбинаций.

Помимо 2 реализованных алгоритмов, я также запускаю тесты данных с помощью
\verb`std::sort` и \verb`std::stable_sort`. Тест выполняется на моем локальном компьютере
(ядро \verb`Linux: 5.10.70-1-lts, процессор: Intel i5-7300HQ (4) @ 3.500 ГГц)`. Чтобы
увидеть оптимизацию, код сначала компилируется без флагов оптимизации. Затем
снова запускается большой случайный тест, но с флагом оптимизации \verb`-O2`.

\subsection{Тест без флагов оптимизации}

\subsubsection{Малая длина последовательности}
\includegraphics[width=\textwidth]{./rendered-results-O0/small-range-random.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/small-range-sorted.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/small-range-reversed-sorted.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/small-range-same-value.png}


\textbf{Анализ}: Последовательность достаточно мала, чтобы все алгоритмы вели себя почти
одинаково.

\subsection{Средняя длина последовательности}
\includegraphics[width=\textwidth]{./rendered-results-O0/medium-range-random.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/medium-range-sorted.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/medium-range-reversed-sorted.png}

\includegraphics[width=\textwidth]{./rendered-results-O0/medium-range-same-value.png}

\textbf{Анализ}: \begin{itemize}
    \item Модифицированный тимсорт показал себя очень хорошо. Он
показывает преимущества параллелизма, а также адаптивность для сортировки почти
отсортированной последовательности.
    \item Честно говоря, алгоритм сортировки дерева работал быстрее, чем стандартная
    функция для случайных случаев, но есть случаи, когда он выполняется хуже. В
        отсортированном случае он работает намного хуже. Причина может быть в
        том, что алгоритм не адаптивен; и доступ к памяти, поскольку он пытался
        выделить много памяти при построении дерева.
\end{itemize}

\subsection{Большая длина последовательности}
\includegraphics[width=\textwidth]{./rendered-results-O0/large-range-random.png}

\textbf{Анализ}: Оба алгоритма работают быстрее стандартных аналогов. Но
сортировка двоичным деревом экономит только половину времени, в то время как
алгоритм временной сортировки очень эффективен. Причина сортировки двоичным
деревом может быть та же, что и выше: сам алгоритм, а также очень плохой доступ
к памяти.

\subsection{С флагом оптимизации -O2}
\includegraphics[width=\textwidth]{./rendered-results/large-range-random.png}

\textbf{Анализ}:\begin{itemize}
\item Алгоритм тимсорт по-прежнему работает быстрее. Но теперь стандартная
    функция запускается с флагами оптимизации, они очень производительны, и
        похоже, что параллелизм едва ли экономит время.
\item Сортировка дерева теперь даже хуже стандартного алгоритма. Это показывает,
    что неэффективный доступ к памяти действительно стоит много времени.
\end{itemize}

Я решил показать только этот тест, потому что в других случаях стандартные
алгоритмы работают очень быстро, а в некоторых случаях они превосходят обе мои
реализации. Мне кажется, что для небольших случаев сортировка - это проблема,
когда применение параллелизма почти не выигрывает по времени.

\subsection{Запуск алгоритма со изменениям количества потоков}
\includegraphics[width=\textwidth]{./rendered-results/num-thread-changes.png}

Вот 4 алгоритма, запускаемых с вводом длины $10^7$ элементов 5 раз и количеством
потоков, измененным с 1 до 4. Время для каждого алгоритма и для каждого
изменения количества потоков считается средним.



\section{Вывод}
В ходе лабораторной работы я приобрел некоторый опыт использования библиотеки
openMP для параллелизма, а также алгоритма распараллеливания с шаблоном
«разделяй и властвуй». В результате я получил приемлемый алгоритм, который
работает быстрее, чем стандартный алгоритм, работающий в одном потоке. Но
стандартные алгоритмы на самом деле очень сильно оптимизированы, поэтому моя
плохая реализация не экономит много времени. И, помимо не очень
оптимизированного алгоритма, меня побили еще и затраты на доступ к памяти.

Но с другой стороны, данные мои алгоритмы в варианте изначально не предназначены
для распараллеливания. Сортировка дерева (если мы действительно строим дерево)
очень затратна из-за доступа к памяти, и хотя Timsort имеет много плюсов в
других случаях, он был разработан как последовательный. Я бы сказал, что доволен
результатом моего модифицированного алгоритма Timsort.

\end{document}

% listing code with:
%    \inputminted[fontsize=\footnotesize]{lang}{realtive-or-absolute-dir}  

% insert image
%    \includegraphics[width=3cm, height=4cm]{img_path}
% vim: wrap tw=80

